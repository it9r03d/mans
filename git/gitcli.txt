GITCLI(7)                         Git Manual                         GITCLI(7)



NNAAMMEE
       gitcli - Git command-line interface and conventions

SSYYNNOOPPSSIISS
       gitcli

DDEESSCCRRIIPPTTIIOONN
       This manual describes the convention used throughout Git CLI.

       Many commands take revisions (most often "commits", but sometimes
       "tree-ish", depending on the context and command) and paths as their
       arguments. Here are the rules:

       +o   Revisions come first and then paths. E.g. in ggiitt ddiiffff vv11..00 vv22..00
           aarrcchh//xx8866 iinncclluuddee//aassmm--xx8866, vv11..00 and vv22..00 are revisions and aarrcchh//xx8866
           and iinncclluuddee//aassmm--xx8866 are paths.

       +o   When an argument can be misunderstood as either a revision or a
           path, they can be disambiguated by placing ---- between them. E.g.
           ggiitt ddiiffff ---- HHEEAADD is, "I have a file called HEAD in my work tree.
           Please show changes between the version I staged in the index and
           what I have in the work tree for that file", not "show difference
           between the HEAD commit and the work tree as a whole". You can say
           ggiitt ddiiffff HHEEAADD ---- to ask for the latter.

       +o   Without disambiguating ----, Git makes a reasonable guess, but errors
           out and asking you to disambiguate when ambiguous. E.g. if you have
           a file called HEAD in your work tree, ggiitt ddiiffff HHEEAADD is ambiguous,
           and you have to say either ggiitt ddiiffff HHEEAADD ---- or ggiitt ddiiffff ---- HHEEAADD to
           disambiguate.

           When writing a script that is expected to handle random user-input,
           it is a good practice to make it explicit which arguments are which
           by placing disambiguating ---- at appropriate places.

       +o   Many commands allow wildcards in paths, but you need to protect
           them from getting globbed by the shell. These two mean different
           things:

               $ git checkout -- *.c
               $ git checkout -- \*.c

           The former lets your shell expand the fileglob, and you are asking
           the dot-C files in your working tree to be overwritten with the
           version in the index. The latter passes the **..cc to Git, and you are
           asking the paths in the index that match the pattern to be checked
           out to your working tree. After running ggiitt aadddd hheelllloo..cc;; rrmm
           hheelllloo..cc, you will _n_o_t see hheelllloo..cc in your working tree with the
           former, but with the latter you will.

       +o   Just as the filesystem _.  (period) refers to the current directory,
           using a _.  as a repository name in Git (a dot-repository) is a
           relative path and means your current repository.

       Here are the rules regarding the "flags" that you should follow when
       you are scripting Git:

       +o   it's preferred to use the non-dashed form of Git commands, which
           means that you should prefer ggiitt ffoooo to ggiitt--ffoooo.

       +o   splitting short options to separate words (prefer ggiitt ffoooo --aa --bb to
           ggiitt ffoooo --aabb, the latter may not even work).

       +o   when a command-line option takes an argument, use the _s_t_u_c_k form.
           In other words, write ggiitt ffoooo --ooAArrgg instead of ggiitt ffoooo --oo AArrgg for
           short options, and ggiitt ffoooo ----lloonngg--oopptt==AArrgg instead of ggiitt ffoooo
           ----lloonngg--oopptt AArrgg for long options. An option that takes optional
           option-argument must be written in the _s_t_u_c_k form.

       +o   when you give a revision parameter to a command, make sure the
           parameter is not ambiguous with a name of a file in the work tree.
           E.g. do not write ggiitt lloogg --11 HHEEAADD but write ggiitt lloogg --11 HHEEAADD ----; the
           former will not work if you happen to have a file called HHEEAADD in
           the work tree.

       +o   many commands allow a long option ----ooppttiioonn to be abbreviated only
           to their unique prefix (e.g. if there is no other option whose name
           begins with oopptt, you may be able to spell ----oopptt to invoke the
           ----ooppttiioonn flag), but you should fully spell them out when writing
           your scripts; later versions of Git may introduce a new option
           whose name shares the same prefix, e.g.  ----ooppttiimmiizzee, to make a
           short prefix that used to be unique no longer unique.

EENNHHAANNCCEEDD OOPPTTIIOONN PPAARRSSEERR
       From the Git 1.5.4 series and further, many Git commands (not all of
       them at the time of the writing though) come with an enhanced option
       parser.

       Here is a list of the facilities provided by this option parser.

   MMaaggiicc OOppttiioonnss
       Commands which have the enhanced option parser activated all understand
       a couple of magic command-line options:

       -h
           gives a pretty printed usage of the command.

               $ git describe -h
               usage: git describe [<options>] <commit-ish>*
                  or: git describe [<options>] --dirty

                   --contains            find the tag that comes after the commit
                   --debug               debug search strategy on stderr
                   --all                 use any ref
                   --tags                use any tag, even unannotated
                   --long                always use long format
                   --abbrev[=<n>]        use <n> digits to display SHA-1s


       --help-all
           Some Git commands take options that are only used for plumbing or
           that are deprecated, and such options are hidden from the default
           usage. This option gives the full list of options.

   NNeeggaattiinngg ooppttiioonnss
       Options with long option names can be negated by prefixing ----nnoo--. For
       example, ggiitt bbrraanncchh has the option ----ttrraacckk which is _o_n by default. You
       can use ----nnoo--ttrraacckk to override that behaviour. The same goes for
       ----ccoolloorr and ----nnoo--ccoolloorr.

   AAggggrreeggaattiinngg sshhoorrtt ooppttiioonnss
       Commands that support the enhanced option parser allow you to aggregate
       short options. This means that you can for example use ggiitt rrmm --rrff or
       ggiitt cclleeaann --ffddxx.

   AAbbbbrreevviiaattiinngg lloonngg ooppttiioonnss
       Commands that support the enhanced option parser accepts unique prefix
       of a long option as if it is fully spelled out, but use this with a
       caution. For example, ggiitt ccoommmmiitt ----aammeenn behaves as if you typed ggiitt
       ccoommmmiitt ----aammeenndd, but that is true only until a later version of Git
       introduces another option that shares the same prefix, e.g. ggiitt ccoommmmiitt
       ----aammeenniittyy option.

   SSeeppaarraattiinngg aarrgguummeenntt ffrroomm tthhee ooppttiioonn
       You can write the mandatory option parameter to an option as a separate
       word on the command line. That means that all the following uses work:

           $ git foo --long-opt=Arg
           $ git foo --long-opt Arg
           $ git foo -oArg
           $ git foo -o Arg


       However, this is NNOOTT allowed for switches with an optional value, where
       the _s_t_u_c_k form must be used:

           $ git describe --abbrev HEAD     # correct
           $ git describe --abbrev=10 HEAD  # correct
           $ git describe --abbrev 10 HEAD  # NOT WHAT YOU MEANT


NNOOTTEESS OONN FFRREEQQUUEENNTTLLYY CCOONNFFUUSSEEDD OOPPTTIIOONNSS
       Many commands that can work on files in the working tree and/or in the
       index can take ----ccaacchheedd and/or ----iinnddeexx options. Sometimes people
       incorrectly think that, because the index was originally called cache,
       these two are synonyms. They are nnoott -- these two options mean very
       different things.

       +o   The ----ccaacchheedd option is used to ask a command that usually works on
           files in the working tree to oonnllyy work with the index. For example,
           ggiitt ggrreepp, when used without a commit to specify from which commit
           to look for strings in, usually works on files in the working tree,
           but with the ----ccaacchheedd option, it looks for strings in the index.

       +o   The ----iinnddeexx option is used to ask a command that usually works on
           files in the working tree to aallssoo affect the index. For example,
           ggiitt ssttaasshh aappppllyy usually merges changes recorded in a stash entry to
           the working tree, but with the ----iinnddeexx option, it also merges
           changes to the index as well.

       ggiitt aappppllyy command can be used with ----ccaacchheedd and ----iinnddeexx (but not at the
       same time). Usually the command only affects the files in the working
       tree, but with ----iinnddeexx, it patches both the files and their index
       entries, and with ----ccaacchheedd, it modifies only the index entries.

       See also hhttttpp::////mmaarrcc..iinnffoo//??ll==ggiitt&&mm==111166556633113355662200335599 and
       hhttttpp::////mmaarrcc..iinnffoo//??ll==ggiitt&&mm==111199115500339933662200227733 for further information.

GGIITT
       Part of the ggiitt(1) suite



Git 2.21.0                        02/24/2019                         GITCLI(7)
